clc
clear all

%1. ВВОД НАЧАЛЬНЫХ ДАННЫХ
coeff_marix=input('Введите количество слоев матрицы коэффициентов\n');
razmer_C=input('Введите размер схемы на слое в формате [ , ]\n');
C0=zeros(razmer_C(1),razmer_C(2),coeff_marix);
for s=1:coeff_marix
 fprintf('Задайте %4.0f-й слой матрицы С по строкам в формате <[строка 1 ;
строка 2; и т.д.]> \nC=', s)
 C1=input('');
 C0(:,:,s)=C1;
end
C0

beta0=input('Введите начальную точку в схеме для поиска в формате
<[__,__,__]> \nbeta1=');
beta1=[beta0(2)+1,beta0(1)+1,beta0(3)+1]; %Переход к новым координатам
%Проверка матрицы коэффициентов на разрешимость задачи Коши
if abs(C0(beta1(1),beta1(2),beta1(3)))<=sum(sum(abs(C0(:,:,beta1(3)))))-
abs(C0(beta1(1),beta1(2),beta1(3)))
 disp('Ошибка ввода матрицы С')
 for s=1:coeff_marix
 fprintf('Задайте %4.0f-й слой матрицы С по строкам в формате <[строка 1 ;
строка 2; и т.д.]> \nC=', s)
 C1=input('');
 C0(:,:,s)=C1;
 end
C0

end
%Ввод матрицы исходных данных
f00=input('Введите точку для поиска f(x,y,z) в формате <[__,__,__]>\nf0= ');
f0=[f00(2)+1,f00(1)+1,f00(3)+1];

initial_marix=input('Введите количество слоев матрицы начальных
данных\nВНИМАНИЕ!!!\n 1) Количество слоев должно быть больше или равно 
количеству слоев в схеме\n 2)Количество слоев должно быть больше или равно
значению третьей координаты точки, в которой ищется значение функции\n');
razmer_F=input('Введите размерность слоя матрицы начальных данных (строка,
столбец) в формате [ , ]\n');
F0=zeros(razmer_F(1),razmer_F(2),initial_marix);
for s=1:initial_marix
 fprintf('Задайте %4.0f-й слой матрицы F по строкам в формате <[строка 1 ;
строка 2; и т.д.]> \nF=', s)
 F1=input('');
 F0(:,:,s)=F1;
end
F0

Q=C0(:,:,end);
Q

% 2. ПОСТРОЕНИЕ БЛОЧНОЙ ТЕПЛИЦЕВОЙ МАТРИЦЫ
% Вектор строки для теплицевой матрицы из матрицы коэффициентов С
p=size(Q,2); %количество элементов в строке (т.е. количество столбцов) в
%матрице коэффициентов
%размер одного блока теплицевой матрицы зависит от p и равен (p x p)
NAD=beta1(1)-1; %количество наддиагоналей в итоговой блочной теплицевой
%матрице
POD=size(Q,1)-beta1(1);%количество поддиагоналей в итоговой блочной
%теплицевой матрице
%Определение количества неизвестных (и, следовательно, размера блочной
%теплицевой матрицы) в верхнем слое трехмерной матрицы
%начальных данных в зависимости от размера верхнего слоя и размера
%матрицы коэффициентов
size_Toeplitz_block=razmer_F(1)*razmer_F(2)-razmer_F(1)*(size(Q,2)-1)-
(razmer_F(2)-(size(Q,2)-1))*(size(Q,1)-1)
T=zeros(size_Toeplitz_block,size_Toeplitz_block);

%Формирование отдельных блоков блочной теплицевой матрицы
%2.1. Формирование блока главной диагонали
a=Q(beta1(1),:)

e=beta1(2);%номер столбца, где расположен элемент матрицы коэффициентов,
по которому ищется значение функции
colomn_c=zeros(p,1);
col=1;
while e>=1
 column_c(col)=a(e);
 col=col+1;
 e=e-1;
end
 column_c;

e=beta1(2);
row_c=zeros(1,p);
r=1;
for m=e:length(a)
 row_c(r)=a(e);
 r=r+1;
 e=e+1;
 end
 row_c;

%Построение блока теплицевой матрицы главной диагонали
disp('Теплицева матрица главной диагонали')
T_0=toeplitz(colomn_c, row_c) %общая матрица для вычисления неизвестных
("В полосе")
%Вставка блока на главную диагональ
for i=0:size_Toeplitz_block/(size(Q,2))-1
 T(((i*p)+1):p*(i+1),((i*p)+1):p*(i+1))=T_0 ;
end
T;

%2.2. Формирование блоков НАДдиагоналей
for w=1:NAD
 a=Q(beta1(1)-w,:);

 e=beta1(2);%номер столбца, где расположен элемент матрицы
%коэффициентов, по которому ищется значение функции
 column_c=zeros(p,1);
 col=1;
 while e>=1
 column_c(col)=a(e);
 col=col+1;
 e=e-1;
 end
 column_c; 

 e=beta1(2);
 row_c=zeros(1,p);
 r=1;

 for m=e:length(a)
 row_c(r)=a(e);
 r=r+1;
 e=e+1;
 end
 row_c;

%Построение блоков теплицевой матрицы наддиагоналей
%disp('Теплицева матрица')
T_NAD=toeplitz(colomn_c, row_c); %общая матрица для вычисления
неизвестных ("В полосе")
%Вставка блоков в наддиагонали
 for i=0:size_Toeplitz_block/(size(Q,2))-1-w
 T((((i*p)+1)):p*(i+1),((i*p)+1)+p*w:p*(i+1)+p*w)=T_NAD ;
 end
T;
end
%2.3. Формирование блоков ПОДдиагоналей
for w=1:POD
 a=Q(beta1(1)+w,:);

 e=beta1(2);%номер столбца, где расположен элемент матрицы
коэффициентов, по которому ищется значение функции
 column_c=zeros(p,1);
 col=1;
 while e>=1
 column_c(col)=a(e);
 col=col+1;
 e=e-1;
 end
 column_c;

 e=beta1(2);
 row_c=zeros(1,p);
 r=1;
 for m=e:length(a)
 row_c(r)=a(e); 
 r=r+1;
 e=e+1;
 end
 row_c;

 %Построение блоков теплицевой матрицы поддиагоналей

 T_POD=toeplitz(colomn_c, row_c); %общая матрица для вычисления
неизвестных
 %Вставка блоков в поддиагонали
 for i=0:size_Toeplitz_block/(size(Q,2))-1-w
 T(((i*p)+1)+p*w:p*(i+1)+p*w,((i*p)+1):p*(i+1))=T_POD ;
 end

end
%2.4. Вывод итоговой блочной теплицевой матрицы
T

%3. ВЫЧИСЛЕНИЕ НЕИЗВЕСТНЫХ НА СЛОЕ
disp('Вычисление неизвестных')

 b=zeros(size(T,1),1);
for k=beta1(3):f0(3) % k - номер слоя
 fprintf('Номер слоя %3.0f\n',k)

 t=1;
 %Умножение матрицы коэффициентов на матрицу начальных данных по
 %столбцам
 for i=0:(size(F0,2)-size(C0,2))
 fprintf('Номер столбца %3.0f\n',i)
 %Умножение матрицы коэффициентов на матрицу начальных данных по
 %строкам
 for j=0:(size(F0,1)-size(C0,1))
 fprintf('Номер строки %3.0f\n',j)
 f_iter=F0(j+1:size(C0,1)+j,(i+1):size(C0,2)+i,k-size(C0,3)+1:k);
 f_new=f_iter.*C0 ;
 b(t)=-(sum(sum(sum(f_new))));
 t=t+1;
 end
 end

 elements=linsolve(T,b);

 m=1
 for i=0:(size(F0,2)-size(C0,2))
 for j=0:(size(F0,1)-size(C0,1))
 F0(beta1(1)+j,beta1(2)+i,k)=elements(m);
 m=m+1;
 end
 end

end
F0
%4. ВЫЧИСЛЕНИЕ ИСКОМОГО ЗНАЧЕНИЯ ФУНКЦИИ В ЗАДАННОЙ
%ТОЧКЕ
fprintf('Искомое значение функции f в точке [%4.0f,%4.0f,%4.0f] равно
%8.4f\n',f00(1),f00(2),f00(3),F0(f0(1),f0(2),f0(3))) 
